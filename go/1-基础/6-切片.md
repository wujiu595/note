---
typora-copy-images-to: img
typora-root-url: img
---

# 6 切片

切片无疑是go语言最重要的数据结构，也是最有趣的数据结构，其英文名为slice。而且也是go语言面试官最津津乐道考察的点，所以我有必要对切片的结构做一个说明。

![1551880142182](/1551880142182.png)

上图中表示的是一个长度为5容量为8的切片存储模型，所以切片数据结构由三部分组成他们分别是：

- 指向底层数组的指针
- 切片的长度
- 切片的容量（最大长度）

切片支持 append 操作可以将新的内容追加到底层数组，也就是填充上面的灰色格子。如果格子满了，切片就需要扩容，底层的数组就会更换。

获取切片长度和容量的方法

获取切片的长度：len()

获取切片的容量：cap()

## 6.1 切片的创建和初始化

切片是使用内置函数make创建的，可以查看如下例子：

```go
package main
import "fmt"
func main() {
    s1 := make([]int, 5, 8)
    s2 := make([]int, 8)
 	fmt.Println(s1)
 	fmt.Println(s2)
}
-------------
[0 0 0 0 0]
[0 0 0 0 0 0 0 0]
```

通过上面的例子我们可以看到，在创建切片时，我们需要添加三个参数

1. 切片的类型
2. 切片的长度
3. 切片的容量（可选如果不填默认满容的切片）

在不赋值的情况下切片里的每个元素与数组相同是元素类型的零值。

除了上面的方式我们也可以使用如下方式进行创建并初始化，通过该方法进行创建并初始化的切片也是满容切片

```go
package main
import "fmt"
func main() {
	s1 := []int{1,2,3,4,5,6,7,8}
    fmt.Println(s1，len(s1),cap(s1))
}
--------------------------
[1 2 3 4 5 6 7 8] 8 8
```

## 6.2 切片的访问和遍历

切片也是通过`a[index]`的形式进行访问切片中的数据的

切片的便利与数组相同也有如下三种方法

方法一：

```go
package main
import "fmt"
func main()  {
	a:=[]int{1,2,3,4,5,6}
	for i:=0;i<len(a);i++{
		fmt.Println(a[i])
	}
}
//[1 2 3 4 5 6]
```

方法二：

```go
package main
import "fmt"
func main()  {
	a=[]int{1,2,3,4,5,6}
	for _,v:=range a{
		fmt.Println(v)
	}
}
//[1 2 3 4 5 6]
```

方法三：

```go
package main
import "fmt"
func main()  {
	a=[]int{1,2,3,4,5,6}
	for i:=range a{
		fmt.Println(a[i])
	}
}
//[1 2 3 4 5 6]
```

## 6.3 切片的追加

### 6.3.1 追加元素

切片可以通过内置函数实现切片的追加，接下来我们看如下例子,就这样我们在s1上追加了三个元素1。

```go
package main
import "fmt"
func main() {
	s1 := make([]int,5,8)
	fmt.Printf("s1=%v,长度为%d,容量为%d\n",s1,cap(s1),cap(s1))
	s1=append(s1,1)
	s1=append(s1,1)
	s1=append(s1,1)
	fmt.Printf("s1=%v,长度为%d,容量为%d",s1,cap(s1),cap(s1))
}
--------------------------------------
s1=[0 0 0 0 0],长度为5,容量为8
s1=[0 0 0 0 0 1 1 1],长度为8,容量为8
```

### 6.3.2 追加切片

我们也可以使用go语言给我们提供的语法糖将一个切片追加到另外一个切片之后

append(s1,s2...),三个点相当于把s2解构。而append的第二个参数是不定餐。

```go
package main
import "fmt"
func main() {
	s1 := make([]int,5,8)
	s2 :=[]int{1,1,1}
	fmt.Printf("s1=%v,长度为%d,容量为%d\n",s1,len(s1),cap(s1))
	s1=append(s1,s2...)
	fmt.Printf("s1=%v,长度为%d,容量为%d",s1,len(s1),cap(s1))
}
--------------------------------------
s1=[0 0 0 0 0],长度为5,容量为8
s1=[0 0 0 0 0 1 1 1],长度为8,容量为8
```

### 6.3.3 扩容

在这里我们再重新考虑一个问题，在上面代码种我们在s1上追加了3个元素让他变成了一个满容切片，如果我们继续在s1上追加元素会发生什么呢？？？？

```go
package main
import "fmt"
func main() {
	s1 := make([]int,5,8)
	s2 :=[]int{1,1,1,1}
	fmt.Printf("s1=%v,长度为%d,容量为%d\n",s1,len(s1),cap(s1))
	s1=append(s1,s2...)
	fmt.Printf("s1=%v,长度为%d,容量为%d",s1,len(s1),cap(s1))
}
--------------------------------------
s1=[0 0 0 0 0],长度为5,容量为8
s1=[0 0 0 0 0 1 1 1 1],长度为9,容量为16
```

在我们追加4个元素超出我们之前设置好的容量8时，切片会自动扩容为原容量的2被也就是16.所以在我们在定义切片变量时要做好充分的考虑，怎样才能使程序更高效的运行。

## 6.4 切片的赋值

首先要明确的是切片直接赋值是一次浅赋值，也就是说切片会拷贝原切片的结构也就是第一层数据，而不会拷贝深层的数组，对拷贝后的切片元素进行更改也会更改原切片的数据

```go
package main
import "fmt"
func main() {
	s1 := make([]int,5,8)
	s2:=s1
	fmt.Println(s1,s2)
	s2[2]=5
	fmt.Println(s1,s2)
}
----------------------
[0 0 0 0 0] [0 0 0 0 0]
[0 0 5 0 0] [0 0 5 0 0]
```

另外也可以使用内建函数 copy（）实现赋值，这种赋值的方式本质就是通过下标来赋值

```go
package main

import "fmt"

func main() {
	s1 := []int{1}
	fmt.Println("s1=",s1)
	s2 := []int{2,3}
	copy(s1,s2)
	fmt.Println("s1=",s1,"s2=",s2)
	s2[1]=5
	fmt.Println("s1=",s1,"s2=",s2)
}
----------------------------
s1= [1]
s1= [2] s2= [2 3]
s1= [2] s2= [2 5]
```

我们可以这样理解上面的例子，我们创建了s1，s2两个切片，并把s2中的数据拷贝到s1中。另外需要注意的是：

- 当len(s1)<len(s2)时,只会把s2中和s1长度相等的数据的数据赋值给s1
- 当len(s1)<=len(s2)时，会把整个s2赋值给s1对应的元素

## 6.5 切片的切割

### 6.5.1切片切割的原理

到目前为止还没有说明切片名字的由来，既然叫着切片，那总得可以切割吧。。切片的切割可以类比字符串的子串，它并不是要把切片割断，而是从母切片中拷贝出一个子切片来，子切片和母切片共享底层数组。下面我们来看一下切片究竟是如何切割的。

```go
package main  
import "fmt"  
func main() {  
    s1 := []int{1,2,3,4,5,6,7}
    //从第二个元素开始不包括第二个 
    //（2,5] 
    s2 := s1[2:5] 
 	fmt.Println(s1, len(s1), cap(s1))  					         fmt.Println(s2, len(s2), cap(s2)) 
}  
 ------------ 
[1 2 3 4 5 6 7] 7 7 
[3 4 5] 3 5
```

看到这样的结果你可能有无数个疑问，为什么切割后的容量变掉了不是说好了共享底层数组的吗？我们来看一下他们的结构s2的容量实际上是起始为止到终止数组终止位置的长度即为5

![1551884543989](/1551884543989.png)

### 6.5.1 数组转换成切片

数组也是可以切割的，在切割后得到一个切片指向元数组

```go
package main
import "fmt"
func main() {
	a := [7]int{1,2,3,4,5,6,7}
	s := a[2:5]
	fmt.Println(s,len(s),cap(s))
}
--------------------------------
[3 4 5] 3 5
```

容量的变化和上面类似，不在做过多的解释









