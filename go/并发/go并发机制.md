---
typora-copy-images-to: img
typora-root-url: img
---

# go并发机制

- 不用共享内存的方式来通信，而是使用通信（chanel传递数据）的方式来共享内存。
- go语言是在操作系统提供的内核线层之上，搭建了一个特有两级线层模型。

gorountine是go语言独创的名称。

把数据放在共享内存种以供多个线层访问。



## 两级模型

KSE：内核空间

M（machine）：一个M代表一个内核线层

P（processor）：一个P代表一个Go语言代码段所必须的资源

G（goroutine）：一个G代表一个Go的代码片段



一个G执行需要M和P的支持，一个M在和一个P建立连接后，就形成了一个有效的G的运行环境（内核空间+上下文环境）。每个P都会包括一个可运行的G的队列，该队列中的G会通过P依次传递给与本地P关联的M获取适当的运行时机。

“当前M“：运行当前G的M

”本地P“：与当前M关联的P称为本地P

![1551164748747](/1551164748747.png)

M的生命周期内只允许和一个KSE内核空间进行连接，相比之下M与P之间、P与G之间的关联是易变的，P和G多数情况下也是1对1的关系，P与G是1对多的关系。

## M

### M的创建

- 多数情况下创建M是都是由于没有足够的M来关联P
- 在运行系统时执行系统监控和垃圾回收也可能导致M的创建

### M的结构

m的主要结构如下：

```go
type M struct{
    //go语言启动之初创建的用于执行一些运行时任务
    go *g
    //代表用于在新的M上启动某个特殊任务的函数：”系统监控“、”GC辅助“、”M自旋“
    mstartfn func()
    //当前正在运行的G的指针
    curg *g
    //当前与M关联的P的指针
    p puibtptr
    //暂存与当前M有潜在关联的P由调度器分配，M与P的预联
    nextp puibtptr
    //表示M是否在寻找可运行的G,在寻找过程种M会处于自旋状态
    spinning
    /*
		runtime.LockOSThread() 锁定G和M的锁定
		runtime.UnlockOSThread() 解锁G和M的锁定
    */
    //当前与M锁定的G
    lockedg *g
}
```

### M的调度

#### 起始

下图描述了M的创建及运行机制

![1551168123872](/1551172660767.png)

#### 停止

运行时系统执行垃圾回收任务的过程中，M有可能被停止，停止后M会加入调度器M的空闲列表中。

M是否空闲也是M是否在空闲列表中决定的。

### M数量设置

我们可以通过 runtime包中的debug/setMaxThreads来设定M的最大数量并返回设置之前的数量，不设定默认的值是10000

```go
import "runtime/debug"

func main(){
    num:=debug.setMaxThreads(100)
    fmt.Println(num)
}
```

值得注意的是：该方法不能设置比当前实际数量还要少的数值，否者会引起恐慌。对于要设定的值也要好好斟酌。

## P

 	P是G能够在M中运行的关键。Go的系统运行适时的让P与M建立或断开关联。P的数量即为可运行的”G的队列数量“，

### P的设置

方法1：

调用runtime包中的GOMAXPROCS方法，该方法的调用会暂时让所有的P脱离可运行状态。p的数量默认等于CPU的核心数，最大256。

```go
import "runtime"
func main(){
  num=runtime.GOMAXPROCS(100)
  fmt.Println(num)  
}
```

方法二：

设置环境变量GOMAXPROCS

### P与M、G

- P与G：当一个G启动后会追加到一个P中等待运行时机
- P与M：当一个P与M建立连接后P中的M才有运行的时机
- P与M：当M因系统调用阻塞时，P会与M断开连接，寻找其他可运行的M，或创建一个新的M

所以M的数量大多数时候大于P，而G的数量取决与Go本身

### p的状态

与M不同P本身是状态的。

- Pidle：p未与m存在关联
- Prunning：p正在与某个m关联
- Psyncall：P中运行的G正在运行系统调用
- Pgcstop：系统需要停止调度，GC回收前会把所有状态都置与该状态
- Pdead：当前P不会再被使用

![1551171512027](/1551172701054.png)

在p的状态变化中如果p进入Pdead状态，那么他的G列表会被加入到调度器的可运行G列表中。



- 每个P都包含一个可运行的G的列表和一个自由G列表
- 自由G列表过大时会被转移到调度器的G的自由列表中。
- 如果P的自由G列表为空时从调度器获取一部分
- 在使用go语句尝试新建一个G时，会优先从P的G自由列表中获取G
- 如果P中没有对应的G那么会新建这个G。

![1551172164291](/1551172164291.png)

## G

一个G代表一个goroutine，与go函数相对应。go语言编辑器会把 go语句变成对内部函数newproc的调用，并把go函数及其参数作为都传递给这个函数





## 核心元素容器



|      中文名称       | 源码中的名称           | 作用域     | 简要说明                |
| :-----------------: | ---------------------- | ---------- | ----------------------- |
|      全局M列表      | runtime.allm           | 运行时系统 | 存放所有M的一个单链表   |
|      全局P列表      | runtime.allp           | 运行时系统 | 存放所有P的一个数组     |
|      全局G列表      | runtime.allg           | 运行时系统 | 存放所有G的一个切片     |
|  调度器的空闲M列表  | runtime.sched.midle    | 调度器     | 存放所有M的一个单链表   |
|  调度器的空闲P列表  | runtime.sched.pidle    | 调度器     | 存放空闲的P的一个单链表 |
| 调度器的可运行G列表 | runtime.sched.runqhead | 调度器     | 存放所有G的一个队列     |
|  调度器的自由G列表  | runtime.sched.runqtail | 调度器     |                         |
|   P的可运行G列表    | runtime.p.runq         | 本地P      |                         |
|    P的自由G列表     | runtime.p.gfree        | 本地P      |                         |

































